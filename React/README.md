### 1. SPA가 무엇인가요?

- 사용자가 페이지를 새로 고치지 않고도 애플리케이션 내에서 모든 작업을 수행할 수 있는 웹 애플리케이션입니다. SPA는 서버에서 완전히 새로운 페이지를 다시 로드하지 않고 현재의 페이지를 동적으로 다시 작성하여 이를 수행합니다. 이로 인해 웹 애플리케이션에 대한 더 나은 사용자 경험과 성능이 향상될 수 있습니다. SPA를 만드는 데 사용할 수 있는 여러 가지 프레임워크와 라이브러리가 있습니다. 가장 인기 있는 프레임워크로는 React, Angular 및 Vue.js가 있습니다. SPA는 웹 애플리케이션을 만드는 인기 있는 방법입니다. 사용자 경험과 성능을 향상시키는 좋은 방법이 될 수 있습니다.

### 2. React를 사용하는 이유에 대해서 말해보세요

- React를 사용하면 재사용 가능한 컴포넌트를 만들 수 있으므로 효율적이고 유지 관리하기 쉽습니다. React는 성능이 뛰어나며 대규모 애플리케이션에 적합합니다. React는 커뮤니티 지원이 매우 좋습니다. 즉, 질문에 답변하고 문제를 해결하는 데 도움을 줄 수 있는 많은 리소스를 사용할 수 있습니다. 전반적으로 React는 배우고 사용하기 쉽고, 효율적이고 유지 관리하기 쉽고, 성능이 뛰어나고, 커뮤니티 지원이 매우 좋은 사용자 인터페이스를 구축하기 위한 인기 있는 프레임워크입니다.

### 3. React 렌더링 성능 향상을 위해 어떻게 해야하나요?

- 렌더링을 최소화합니다. 렌더링할 필요가 없는 컴포넌트는 렌더링하지 마십시오. 캐싱을 사용합니다. 자주 변경되지 않는 데이터는 캐시하여 성능을 향상시킬 수 있습니다. 최적화된 라이브러리를 사용합니다. React에는 성능을 향상시키도록 설계된 여러 라이브러리가 있습니다. 성능 로깅을 사용합니다. 성능 로깅을 사용하면 렌더링 성능을 식별하고 최적화할 수 있습니다.

### 4. 생명주기 메소드에 대해서 설명해보세요

- 컴포넌트의 수명은 페이지에 렌더링되기 전인 준비과정 에서 시작하여 페이지에서 사라질 때 끝납니다. 컴포넌트를 처음으로 렌더링 할 때 , 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후 로 어떤 작업을 처리해야 할 수도 있고, 불필요한 업데이트를 방지 해야 할 수도 있습니다. 생명주기 메소드는 컴포넌트의 특정 시점에 호출되는 함수입니다. 가장 일반적인 생명주기 메서드는 다음과 같습니다.

1. constructor: 컴포넌트가 처음 생성될 때 호출됩니다.
2. render: 컴포넌트의 DOM 표현식을 반환합니다.
3. componentDidMount: 컴포넌트가 DOM에 렌더링될 때 호출됩니다.
4. componentDidUpdate: 컴포넌트가 업데이트될 때 호출됩니다.
5. componentWillUnmount: 컴포넌트가 DOM에서 제거될 때 호출됩니다.

생명주기 메서드를 사용하여 컴포넌트가 생성, 렌더링, 업데이트 또는 제거될 때 실행되는 코드를 작성할 수 있습니다.

### 5. key props를 사용하는 이유가 무엇인가요?

- React에서 key prop은 컴포넌트의 각 자식 요소에 고유한 식별자를 할당하는 데 사용됩니다. React는 key prop을 사용하여 어떤 자식 요소가 변경, 추가 또는 제거되었는지 식별하고 필요한 경우에만 DOM을 업데이트합니다. key prop이 없으면 React는 모든 자식 요소를 다시 렌더링해야 합니다.

### 6. 최적화가 무조건 좋은가요?

- 최적화는 항상 좋은 것은 아닙니다. 성능 향상과 관련하여 최적화를 수행하기 전에 항상 비용과 이점을 비교해야 합니다. 최적화는 성능을 향상시킬 수 있지만 코드를 더 복잡하게 만들고 유지 관리하기 어렵게 만들 수도 있습니다. 최적화를 하기 전에 고려해볼 사항이 있습니다. 최적화가 필요한지 여부: 앱이 이미 충분히 빠른 경우 최적화할 필요가 없습니다. 최적화할 부분: 코드의 어떤 부분을 최적화할지 결정해야 합니다. 최적화할 부분을 선택할 때 성능에 가장 큰 영향을 미치는 부분을 선택해야 합니다. 사용할 최적화 기술: 최적화하는 데 사용할 기술을 결정해야 합니다. 사용할 수 있는 다양한 최적화 기술이 있으므로 앱에 가장 적합한 기술을 선택해야 합니다.
  코드 테스트: 최적화가 완료되면 코드를 테스트하여 예상대로 작동하는지 확인해야 합니다. 최적화를 수행하기 전에 항상 비용과 이점을 비교하는 것이 중요합니다. 최적화가 성능을 향상시킬 것이라고 확신하지 못하는 경우에는 수행하지 않는 것이 좋습니다.

### 7. React에서 메모이제이션을 어떤 방식으로 하나요?

- useMemo 훅을 사용하여 메모이제이션을 수행합니다. useMemo 훅은 계산된 값을 의존성 객체에 저장하고, 의존성 객체가 변경될 때만 계산을 다시 실행합니다. useMemo 훅은 자주 업데이트되지 않는 계산된 값에 대해 성능을 최적화하는 데 사용할 수 있습니다. 예를 들어, 컴포넌트의 상태에 따라 달라지는 값을 계산하는 함수가 있는 경우 useMemo 훅을 사용하여 함수를 메모이제이션할 수 있습니다. 이렇게 하면 컴포넌트의 상태가 변경될 때마다 함수가 다시 실행되지 않고 이전에 계산한 값이 반환됩니다. useMemo 훅은 계산된 값에 대해 성능을 최적화하는 데 사용할 수 있는 강력한 도구입니다. 자주 업데이트되지 않는 계산된 값이 있는 경우 useMemo 훅을 사용하여 성능을 향상시킬 수 있습니다.

### 8. 왜 state를 직접 바꾸지 않고 setState를 사용해야 하나요?

- React에서 직접 상태를 변경하면 렌더링이 발생하지 않습니다. setState를 사용하면 React는 변경 사항을 추적하고 변경 사항이 발생할 때만 컴포넌트를 다시 렌더링합니다. 이는 React의 단방향 데이터 흐름을 보장하는 데 도움이 되며, 이는 React가 일관되고 예측 가능한 방식으로 작동하도록 하는 데 도움이 됩니다.

### 9. DOM과 가상 DOM(Virtual DOM)의 차이

- 가상 DOM을 이용하면 실제 DOM에 변화를 바로 적용하는 것보다 전체적인 프로세스를 효율적으로 수행할 수 있다. 속도 차원의 문제라기 보다는, 연산 횟수 차원의 문제라고 할 수 있다. 우선 각각의 DOM 조작은 레이아웃 변화, 트리 변화 및 렌더링을 일으킨다.
  가상 DOM을 이용하지 않으면 변화가 있을 때마다 DOM 조작이 일어나고 이에 대한 연산이 수행되며 렌더링되기 때문에 변화를 적용할 때 드는 비용이 비교적 크다. 가상 DOM을 이용하면 일종의 '오프라인' DOM 트리(이는 렌더링 되지 않는다 → 연산 비용이 적다!)에 변화들을 적용한 뒤 그 변화를 하나로 묶어서 한번에 실제 DOM에 전달하기 때문에 연산 횟수가 줄어들고 변화에 대한 비용이 비교적 작다.

### 10. React가 널리 사용되는 이유는?

- 리액트는 애플리케이션을 구축할 때 다음과 같은 다양한 이점을 제공하기 때문에 널리 사용된다. 동적 페이지(유저 인터랙션에 따라 페이지 구성을 달리 해주어야 하는 페이지)의 유저 인터페이스를 효율적으로 유지보수 및 관리할 수 있다. 구체적으로는 컴포넌트 기반 아키텍처이므로, 재사용 가능한 컴포넌트를 개발하고 여러 부분에서 가져다가 사용할 수 있어 개발 생산성이 높고 유지보수가 용이하다.
  HTML 문법과 유사한 JSX를 사용하기 때문에, HTML을 작성하듯 코드를 작성할 수 있어 편리하며 가독성이 좋다. 동적 페이지에선 유저 인터랙션에 의한 view의 변화가 빈번하다. 리액트에선 가상 DOM을 사용해서, 최종적인 변화만을 실제 DOM에 전달하기 때문에 연산 비용이 비교적 적게 든다.

### 11. React에서 props란 무엇인가?

- 리액트에서 props는 프로퍼티(properties, 속성)의 줄임말로, 읽기만 가능하며(read-only) 불변성을 지닌 요소를 의미한다.
  애플리케이션에서 props는 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 계층 구조를 따른다. 반대는 불가능하다. 리액트는 단방향 데이터 흐름 모델을 사용하기 때문이다.

### 12. React 사용할 때의 단점은 없는가?

- 앵귤러와 같은 프레임워크와 비교하자면 리액트는 단순 라이브러리이기 때문에, 더 많은 기능을 사용하고자 한다면 Redux, Router 등 많은 dependencies(의존성 모듈)가 필요하다.
  단방향 데이터 바인딩만 제공하는 것이 복잡도를 줄이기 때문에 장점이기도 하지만, 양방향 바인딩에 비해서 더 많은 양의 코드를 작성해야 하므로 불편할 수 있다고 한다.

### 13. React에서 상태(state)란 무엇인가?

- 리액트에서 상태는 컴포넌트의 동작 및 렌더링과 같은 부분을 제어하는 데이터 또는 객체를 의미한다. 상태를 이용하여, 동적이고 인터랙티브한 컴포넌트를 쉽게 개발할 수 있다.

### 14. React에서 HOC(고차 컴포넌트)란?

- 반복되는 컴포넌트 로직을 쉽게 재사용하기 위한 기술로서, 컴포넌트를 취하여 새로운 컴포넌트를 반환하는 함수를 의미한다.
  우선 HOC의 네이밍은 with**\_** (예: withTheme) 형식으로 짓는다. HOC은 컴포넌트를 인자로 전달 받는다. 그리고 전달 받은 컴포넌트를 기반으로, 전달 받은 props와 HOC 내부에서 추가적으로 생성한 props를 주입한 새로운 컴포넌트를 반환한다.

- HOC은 다음의 경우에서 사용할 수 있다.
  유저 인증 로직 처리 (예시 참고)
  로딩/에러 로직 처리
  이렇게 HOC을 사용하면, 비즈니스 로직과 presentational 컴포넌트를 분리할 수 있어 깔끔하다.

### 15. JSX란?

- JSX는 JavaScript XML(eXtensible Markup Language)의 약어로, HTML 요소에 유효한 자바스크립트 객체를 내장할 수 있는 자바스크립트 확장이다. 리액트에선 보통 HTML과 자바스크립트를 별도로 작성하기 보다는, JSX를 이용하여 HTML과 자바스크립트를 모두 포함하고 있는 '컴포넌트'를 생성한다. JSX는 HTML보다는 자바스크립트에 가깝다고 한다.

### 16. React의 '컴포넌트 기반 아키텍처'의 의미가 무엇인가?

- React에서 컴포넌트는 애플리케이션 UI 구축의 기반이다. 컴포넌트 기반 시스템이 구축되면, 각각의 개별적인 구성 요소들은 재사용이 가능하며 서로 독립적으로 존재한다. 즉 구성 요소 간 서로 의존하지 않으며 애플리케이션의 UI 개발이 용이해진다.

### 17. CRA란?

- CRA(create-react-app)은 React의 공식 CLI(명령줄 인터페이스)로서, SPA 개발 초기 세팅을 편리하게 할 수 있도록 한다.
  애플리케이션을 개발할 때 create-react-app을 사용하면 개발자가 빌드 구성을 직접 하지 않아도 되기 때문에 코드에만 집중할 수 있어 효율적으로 개발을 할 수 있다.

### 18. React 라우터같은 Client Side Routing 에 대해서 설명하세요.

- 웹 페이지의 렌더링이 클라이언트 즉, 브라우저 측에서 일어나는 것을 의미합니다. 서버와 클라이언트 간의 데이터 트래픽이 감소하고 렌더링이 한번만 있기 때문에 페이지 이동이 빠르다는 장점이 있지만, 검색 최적화 사용은 어렵다는 단점이 있습니다. 또한 보안관련해서는 쿠키에 사용자 정보를 저장해야해서 위험 요소가 될 수 있습니다.

### 19. state를 직접 변경하지 않고 setState를 사용하는 이유에 대해서 설명하세요.

- state는 불변성을 유지해야하기 때문입니다. 컴포넌트는 setState를 비교해서 업데이트가 필요한 경우에만 render함수를 호출하는데 state를 직접 수정하게 되면 리액트가 render함수를 호출하지 않아 상태 변경이 일어나도 렌더링이 일어나지 않을 수 있습니다.

### 20. Props Drilling 이란 무엇인가요?

- React의 컴포넌트 트리에서 데이터를 전달하기 위해서 필요한 과정을 의미합니다. 예를 들어 우리가 App.js에서 데이터를 하위컴포넌트까지 쭉 전달하면 데이터가 변경되었을 때 일일히 고쳐야하는 불편함이 있습니다. 이를 해결하기 위해 전역 상태 관리 라이브러리인 Redux, recoil를 이용하여 해당 값이 필요한 컴포넌트에게 직접 불러서 사용하는 해결하는 방안이 있습니다.

### 21. Class Component와 Function Component의 차이점에 대해서 설명하세요.

- class Component는 여러 단계의 상속으로 이루어져 있습니다. 그리하여 복잡성과 오류 가능성을 증가 시켰습니다. 이로 인해 Function Component가 탄생하게 되었고, class component는 라이프 사이클을 가지며 이로인해 각각 생명주기 메소드에 대해 알고 있어야 합니다. 하지만 function component는 이러한 기능을 hook을 사용하여 생명주기에 원하는 동작을 하게 합니다.

### 22. React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해서 설명하세요.

- React는 상태를 불변성을 띄게 변경합니다. 그로 인해 상태 객체의 주소값이 변경이 되면 변화가 되었다는 것을 알 수 있습니다.

### 23. useCallback의 동작원리

- useCallback은 변수가 선언되어지면 해당 함수가 실행되어진다. 그 후에 deps의 변경을 통해 값이 변경이 되면 새로운 함수를 return하고, 값이 변경이 되어지지 않는 다면 기존 함수를 return한다.

### 24. useEffect 메소드로 componentWillUnmount 가 동작할 수 있는 방법에 대해서 설명하세요.

- useEffect 코드 내부에서 return하는 익명함수를 작성하는 방법으로 componentwillUnmount를 구현할 수 있습니다.

```
useEffect(() => {
    console.log('컴포넌트가 화면에 나타남');
    return () => {
      console.log('컴포넌트가 화면에서 사라짐');
    };
  }, []);
```

- componentwillUnmonunt는 컴포넌트가 화면에서 사라질 때 나타나는 라이플 사이클입니다.

### 25. React Hooks의 장점은 무엇인가요?

- Hooks의 장점은 로직의 재사용이 가능하고 관리가 쉽다는 것입니다. 함수 안에서 다른 함수를 호출하는 것으로 새로운 hook을 만들어 볼 수 있습니다. 기존의 class component는 여러 단계의 상속으로 인해 전반적으로 복잡성과 오류 가능성을 증가시켰습니다. 하지만 function component에 hooks에 도입되면서 class component가 가지고 있는 기능을 모두 사용할 수 있음은 물론이고 기존 class component 복잡성, 재사용성의 단점들까지 해결됩니다.

### 26. React 내부 작동 원리를 재조정 (Reconciliation) 개념과 함께 설명하세요.

- React에서 DOM을 어떻게 렌더링하고 브라우저 이벤트를 처리하나요?
  실제로 DOM을 제어하지 않고 중간에 virtual DOM을 두어 virtual DOM이 변경될 때, 실제 DOM을 변경하도록 설계되어있습니다. 이 작업을 Reconciliation이라고 합니다. virtual DOM을 갱신하는 방법에는 setState()메소드를 호출하는 방법과 redux의 경우처럼 store가 변하면 다시 최상위 컴포넌트의 render()함수를 호출해서 갱신하는 2가지 방법이 있습니다.

### 27. key는 어떻게 사용되나요?

- React에서 collection을 렌더링할 때 요소와 데이터 사이의 관계를 추적하기 쉽도록 반복되는 각 요소에 key를 추가하는 것이 중요합니다. 키는 고유한 ID(이상적으로는 uuid 또는 기타의 고유한 문자열)을 사용해야 하지만, 마지막 수단으로 Array index를 사용할 수 도 있습니다.

```
<ul>
  {todos.map((todo) =>
    <li key={todo.id}>
      {todo.text}
    </li>
  )};
</ul>
```

- key를 사용하지 않으면 collection에 아이템을 추가하거나 제거할 때 예상하지 못한 동작 결과가 발생할 수 있습니다.

### 28. React Context는 무엇인가요?

- React는 하나의 애플리케이션 안에서 다수개의 컴포넌트들이 상태를 공유할 때 발생하는 문제들에 대해 대응하기 위한 Context API를 제공합니다. Context가 도입되기 이전에는 Redux와 같은 별도의 상태 관리 라이브러리를 추가하는 것이 유일한 방법이었습니다. 하지만 개발자들은 소규모의 앱에서는 Redux가 불필요한 복잡성을 유발한다고 느꼈습니다.

### 29. 생명주기 메소드는 무엇인가요?

- 클래스 기반 컴포넌트들은 마운트되었을 때나 언마운트될 때와 같이 생명주기 중 특정 시점에 호출되는 특별한 메소드를 선언할 수 있습니다. 이는 컴포넌트가 필요할 때 세팅 및 해체, 타이머를 설정하거나 브라우저 이벤트에 바인딩할 시 유용합니다.

아래의 생명주기 메소드들은 컴포넌트를 불러오기 위해 사용할 수 있습니다.

- componentWillMount: 컴포넌트가 생성된 후 DOM에 렌더링되기전 호출됩니다.
- componentDidMount: 첫 렌더링이 끝나고 컴포넌트의 DOM 엘리먼트가 사용가능할 시 호출됩니다.
- componentWillReceiveProps: props가 업데이트 될 때 호출됩니다.
- shouldComponentUpdate: 새로운 props를 받았을 때 호출되며, 성능 최적화를 위해 재렌더링을 막을 수 있습니다.
- componentWillUpdate: 새로운 props를 받았고 shouldComponentUpdate가 true를 리턴할 때 호출됩니다.
- componentDidUpdate: 컴포넌트가 업데이트된 후에 호출됩니다.
- componentWillUnmount: 컴포넌트가 DOM에서 제거되기 전 호출되어 이벤트 리스너 등을 정리할 수 있게 해줍니다.

### 30. Static Site Generator에 대해서 아시나요?

- Static Site Generator(SSG)는 정적인 HTML, CSS, JavaScript 파일을 생성하는 소프트웨어입니다. SSG를 사용하면 동적인 서버 측 프로그래밍 없이 정적인 웹 페이지를 생성할 수 있습니다. 이에 대한 몇 가지 장점은 다음과 같습니다. 정적인 파일을 생성하기 때문에, 웹 서버의 보안에 대한 걱정이 줄어듭니다. 정적인 파일은 웹 브라우저에 의해 더 빠르게 다운로드됩니다. 따라서 로딩 속도가 향상되며 사용자 경험이 좋아집니다. GatsbyJS, Next.js, Hugo, Jekyll 등과 같은 플랫폼들이 있습니다.

### 31. 비동기 함수에 대해서 설명해 보세요.

- 비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다. 비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다. 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.

### 32. TDD란 무엇인가요?

- TDD(Test-Driven Development)는 테스트 주도 개발 방법론의 준말로, 개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다. TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다. 또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다.

### 33. 클래스형 컴포넌트와 함수형 컴포넌트의 차이는 무엇일까요?

- 리액트에서 컴포넌트를 만드는 방법에는 클래스형 컴포넌트(class components)와 함수형 컴포넌트(functional components)가 있습니다. 클래스형 컴포넌트는 ES6의 클래스(class)를 사용하여 컴포넌트를 정의합니다. 이 방식은 React의 컴포넌트의 상태(state)와 생명주기(lifecycle)를 다룰 때 매우 유용합니다.
  반면에 함수형 컴포넌트는 ES6의 화살표 함수(arrow function)를 사용하여 컴포넌트를 정의합니다. 이 방식은 훅(hook) API와 함께 많이 사용되며, 컴포넌트의 상태와 생명주기를 다룰 때도 유용합니다.
  클래스형 컴포넌트와 함수형 컴포넌트의 가장 큰 차이점은 상태와 생명주기의 다루는 방식입니다. 클래스형 컴포넌트는 상태를 this.state로 정의하고, 생명주기 메서드를 오버라이드하여 다양한 작업을 수행합니다. 반면에 함수형 컴포넌트는 상태를 useState 훅을 사용하여 정의하고, useEffect 훅을 사용하여 생명주기를 다룹니다. 또한, 클래스형 컴포넌트에서는 this 키워드를 사용하여 상태나 메서드를 참조하며, 함수형 컴포넌트에서는 this 키워드를 사용하지 않습니다. 이러한 차이점 때문에, 함수형 컴포넌트는 더 간결하고 가독성이 좋아지며, 테스트와 리팩토링이 쉽게 이루어질 수 있습니다.

### 34. useEffect란?

- 컴포넌트가 렌더링 되거나 업데이트 될 때 그 안에 있는 기능을 실행할 수 있는 React Hooks중 하나다. 컴포넌트의 특정 값이 업데이트 될 때 해당 기능으로 작동시키고 싶으면 두 번째 파라미터의 배열에 그 값을 넣어주면 된다. 컴포넌트가 언마운트 되거나 업데이트 되기 직전에 원하는 작업을 하고 싶다면 뒷정리 함수를 리턴하면 된다. 실제로 무한스크롤을 구현 할 때 스크롤 이벤트를 삭제하기 위해 사용했었다.
