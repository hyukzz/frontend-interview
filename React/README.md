### 1. SPA가 무엇인가요?

- 사용자가 페이지를 새로 고치지 않고도 애플리케이션 내에서 모든 작업을 수행할 수 있는 웹 애플리케이션입니다. SPA는 서버에서 완전히 새로운 페이지를 다시 로드하지 않고 현재의 페이지를 동적으로 다시 작성하여 이를 수행합니다. 이로 인해 웹 애플리케이션에 대한 더 나은 사용자 경험과 성능이 향상될 수 있습니다. SPA를 만드는 데 사용할 수 있는 여러 가지 프레임워크와 라이브러리가 있습니다. 가장 인기 있는 프레임워크로는 React, Angular 및 Vue.js가 있습니다. SPA는 웹 애플리케이션을 만드는 인기 있는 방법입니다. 사용자 경험과 성능을 향상시키는 좋은 방법이 될 수 있습니다.

### 2. React를 사용하는 이유에 대해서 말해보세요

- React를 사용하면 재사용 가능한 컴포넌트를 만들 수 있으므로 효율적이고 유지 관리하기 쉽습니다. React는 성능이 뛰어나며 대규모 애플리케이션에 적합합니다. React는 커뮤니티 지원이 매우 좋습니다. 즉, 질문에 답변하고 문제를 해결하는 데 도움을 줄 수 있는 많은 리소스를 사용할 수 있습니다. 전반적으로 React는 배우고 사용하기 쉽고, 효율적이고 유지 관리하기 쉽고, 성능이 뛰어나고, 커뮤니티 지원이 매우 좋은 사용자 인터페이스를 구축하기 위한 인기 있는 프레임워크입니다.

### 3. React 렌더링 성능 향상을 위해 어떻게 해야하나요?

- 렌더링을 최소화합니다. 렌더링할 필요가 없는 컴포넌트는 렌더링하지 마십시오. 캐싱을 사용합니다. 자주 변경되지 않는 데이터는 캐시하여 성능을 향상시킬 수 있습니다. 최적화된 라이브러리를 사용합니다. React에는 성능을 향상시키도록 설계된 여러 라이브러리가 있습니다. 성능 로깅을 사용합니다. 성능 로깅을 사용하면 렌더링 성능을 식별하고 최적화할 수 있습니다.

### 4. 생명주기 메소드에 대해서 설명해보세요

- 컴포넌트의 수명은 페이지에 렌더링되기 전인 준비과정 에서 시작하여 페이지에서 사라질 때 끝납니다. 컴포넌트를 처음으로 렌더링 할 때 , 어떤 작업을 처리해야하거나 컴포넌트를 업데이트하기 전후 로 어떤 작업을 처리해야 할 수도 있고, 불필요한 업데이트를 방지 해야 할 수도 있습니다. 생명주기 메소드는 컴포넌트의 특정 시점에 호출되는 함수입니다. 가장 일반적인 생명주기 메서드는 다음과 같습니다.

1. constructor: 컴포넌트가 처음 생성될 때 호출됩니다.
2. render: 컴포넌트의 DOM 표현식을 반환합니다.
3. componentDidMount: 컴포넌트가 DOM에 렌더링될 때 호출됩니다.
4. componentDidUpdate: 컴포넌트가 업데이트될 때 호출됩니다.
5. componentWillUnmount: 컴포넌트가 DOM에서 제거될 때 호출됩니다.

생명주기 메서드를 사용하여 컴포넌트가 생성, 렌더링, 업데이트 또는 제거될 때 실행되는 코드를 작성할 수 있습니다.

### 5. key props를 사용하는 이유가 무엇인가요?

- React에서 key prop은 컴포넌트의 각 자식 요소에 고유한 식별자를 할당하는 데 사용됩니다. React는 key prop을 사용하여 어떤 자식 요소가 변경, 추가 또는 제거되었는지 식별하고 필요한 경우에만 DOM을 업데이트합니다. key prop이 없으면 React는 모든 자식 요소를 다시 렌더링해야 합니다.

### 6. 최적화가 무조건 좋은가요?

- 최적화는 항상 좋은 것은 아닙니다. 성능 향상과 관련하여 최적화를 수행하기 전에 항상 비용과 이점을 비교해야 합니다. 최적화는 성능을 향상시킬 수 있지만 코드를 더 복잡하게 만들고 유지 관리하기 어렵게 만들 수도 있습니다. 최적화를 하기 전에 고려해볼 사항이 있습니다. 최적화가 필요한지 여부: 앱이 이미 충분히 빠른 경우 최적화할 필요가 없습니다. 최적화할 부분: 코드의 어떤 부분을 최적화할지 결정해야 합니다. 최적화할 부분을 선택할 때 성능에 가장 큰 영향을 미치는 부분을 선택해야 합니다. 사용할 최적화 기술: 최적화하는 데 사용할 기술을 결정해야 합니다. 사용할 수 있는 다양한 최적화 기술이 있으므로 앱에 가장 적합한 기술을 선택해야 합니다.
  코드 테스트: 최적화가 완료되면 코드를 테스트하여 예상대로 작동하는지 확인해야 합니다. 최적화를 수행하기 전에 항상 비용과 이점을 비교하는 것이 중요합니다. 최적화가 성능을 향상시킬 것이라고 확신하지 못하는 경우에는 수행하지 않는 것이 좋습니다.

### 7. React에서 메모이제이션을 어떤 방식으로 하나요?

- useMemo 훅을 사용하여 메모이제이션을 수행합니다. useMemo 훅은 계산된 값을 의존성 객체에 저장하고, 의존성 객체가 변경될 때만 계산을 다시 실행합니다. useMemo 훅은 자주 업데이트되지 않는 계산된 값에 대해 성능을 최적화하는 데 사용할 수 있습니다. 예를 들어, 컴포넌트의 상태에 따라 달라지는 값을 계산하는 함수가 있는 경우 useMemo 훅을 사용하여 함수를 메모이제이션할 수 있습니다. 이렇게 하면 컴포넌트의 상태가 변경될 때마다 함수가 다시 실행되지 않고 이전에 계산한 값이 반환됩니다. useMemo 훅은 계산된 값에 대해 성능을 최적화하는 데 사용할 수 있는 강력한 도구입니다. 자주 업데이트되지 않는 계산된 값이 있는 경우 useMemo 훅을 사용하여 성능을 향상시킬 수 있습니다.

### 8. 왜 state를 직접 바꾸지 않고 setState를 사용해야 하나요?

- React에서 직접 상태를 변경하면 렌더링이 발생하지 않습니다. setState를 사용하면 React는 변경 사항을 추적하고 변경 사항이 발생할 때만 컴포넌트를 다시 렌더링합니다. 이는 React의 단방향 데이터 흐름을 보장하는 데 도움이 되며, 이는 React가 일관되고 예측 가능한 방식으로 작동하도록 하는 데 도움이 됩니다.

### 9. DOM과 가상 DOM(Virtual DOM)의 차이

- 가상 DOM을 이용하면 실제 DOM에 변화를 바로 적용하는 것보다 전체적인 프로세스를 효율적으로 수행할 수 있다. 속도 차원의 문제라기 보다는, 연산 횟수 차원의 문제라고 할 수 있다. 우선 각각의 DOM 조작은 레이아웃 변화, 트리 변화 및 렌더링을 일으킨다.
  가상 DOM을 이용하지 않으면 변화가 있을 때마다 DOM 조작이 일어나고 이에 대한 연산이 수행되며 렌더링되기 때문에 변화를 적용할 때 드는 비용이 비교적 크다. 가상 DOM을 이용하면 일종의 '오프라인' DOM 트리(이는 렌더링 되지 않는다 → 연산 비용이 적다!)에 변화들을 적용한 뒤 그 변화를 하나로 묶어서 한번에 실제 DOM에 전달하기 때문에 연산 횟수가 줄어들고 변화에 대한 비용이 비교적 작다.

### 10. React가 널리 사용되는 이유는?

- 리액트는 애플리케이션을 구축할 때 다음과 같은 다양한 이점을 제공하기 때문에 널리 사용된다. 동적 페이지(유저 인터랙션에 따라 페이지 구성을 달리 해주어야 하는 페이지)의 유저 인터페이스를 효율적으로 유지보수 및 관리할 수 있다. 구체적으로는 컴포넌트 기반 아키텍처이므로, 재사용 가능한 컴포넌트를 개발하고 여러 부분에서 가져다가 사용할 수 있어 개발 생산성이 높고 유지보수가 용이하다.
  HTML 문법과 유사한 JSX를 사용하기 때문에, HTML을 작성하듯 코드를 작성할 수 있어 편리하며 가독성이 좋다. 동적 페이지에선 유저 인터랙션에 의한 view의 변화가 빈번하다. 리액트에선 가상 DOM을 사용해서, 최종적인 변화만을 실제 DOM에 전달하기 때문에 연산 비용이 비교적 적게 든다.

### 11. React에서 props란 무엇인가?

- 리액트에서 props는 프로퍼티(properties, 속성)의 줄임말로, 읽기만 가능하며(read-only) 불변성을 지닌 요소를 의미한다.
  애플리케이션에서 props는 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 계층 구조를 따른다. 반대는 불가능하다. 리액트는 단방향 데이터 흐름 모델을 사용하기 때문이다.

### 12. React 사용할 때의 단점은 없는가?

- 앵귤러와 같은 프레임워크와 비교하자면 리액트는 단순 라이브러리이기 때문에, 더 많은 기능을 사용하고자 한다면 Redux, Router 등 많은 dependencies(의존성 모듈)가 필요하다.
  단방향 데이터 바인딩만 제공하는 것이 복잡도를 줄이기 때문에 장점이기도 하지만, 양방향 바인딩에 비해서 더 많은 양의 코드를 작성해야 하므로 불편할 수 있다고 한다.
